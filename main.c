#include <windows.h>
#include <stdio.h>
#include <conio.h>

#include "system.h"
#include "packet.h"
#include "uart.h"
#include "net.h"
#include "kernel.h"

extern int MakeString(BYTE* oBuf);

//////////////////////////////////////////////////////////////////////////////
// 16*8的点阵数据，每个点3个字节
//   第1个字节代表红
//   第2个字节代表绿
//   第3个字节代表蓝(无效)
// 点阵按照纵向先序，第1,2列为红，第3,4列为绿，第5,6列为黄，第7,8列为红，第9,10列为绿，第11,12列为黄......
BYTE dibbuffer1[]={
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, //第1列
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, //第2列
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, //第3列 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, //第4列 
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, //第5列  
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, //第6列  
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, //第7列
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, //第8列
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, //第9列 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, //第10列 
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, //第11列  
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
  0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, //第12列  
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, //第13列
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 
  0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, //第14列
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, //第15列 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 
  0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00,  //第16列 
};
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// 16*16的点阵数据，汉字"年"的点阵数据
//   第1个字节代表红
//   第2个字节代表绿
//   第3个字节代表蓝(无效)
BYTE dibbuffer2[]={
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,  
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};
//////////////////////////////////////////////////////////////////////////////

char remotehost[]="192.168.1.99";

void PrintTree(PRoot root)
{
  int i,l;
  PLeaf   leaf;
  PObject object;
  PString string;

  printf("\n----------- 显示树 -------------\n");
  if (root==NULL)
  {
    printf("Root is NULL\r\n");
    return;
  }

  switch (root->id){
    case ROOT_DOWNLOAD:
      printf("- Root (ID=ROOT_DOWNLOAD size=%d)\n", root->size);
      break;
    case ROOT_PLAY:
      printf("- Root (ID=ROOT_PLAY Count=%d size=%d)\n", root->count, root->size);
      break;
    default:
      printf(" Unknow Root Type\r\n");
      return;
  }

  leaf=(PLeaf)((DWORD)root+sizeof(TRoot));
  for (i=0; i<root->count; i++)
  {
    printf(" |\n");
    printf(" +- Leaf (id=%0.4X Count=%d DisplayTime=%d)\n", leaf->id, leaf->count, leaf->time);
    object=(PObject)((DWORD)leaf+sizeof(TLeaf));
    for (l=0; l<leaf->count; l++)
    {
      if (object->id==OBJECT_STRING)
      {
        string=(PString)object;
        if (i<root->count-1)
	    {
          printf(" | |\n");
          printf(" | +- OBJECT_STRING");
          printf(" (Color=%0.8X,FontSet=%d,Method=%d,显示内容=%s)\n", string->color, string->fontset, string->method, (char *)((DWORD)string+sizeof(TString)));
        }
        else
        {
          printf("   |\n");
          printf("   +- OBJECT_STRING");
          printf(" (Color=%0.8X,FontSet=%d,Method=%d,显示内容=%s)\n", string->color, string->fontset, string->method, (char *)((DWORD)string+sizeof(TString)));
        }
      }
	  else if (object->id==OBJECT_WINDOW)
	  {
        if (i<root->count-1)
	    {
          printf(" | |\n");
          printf(" | +- OBJECT_WINDOW");
          //printf(" (Color=%0.8X,FontSet=%d,Method=%d,显示内容=%s)\n", string->color, string->fontset, string->method, (char *)((DWORD)string+sizeof(TString)));
        }
        else
        {
          printf("   |\n");
          printf("   +- OBJECT_WINDOW");
          //printf(" (Color=%0.8X,FontSet=%d,Method=%d,显示内容=%s)\n", string->color, string->fontset, string->method, (char *)((DWORD)string+sizeof(TString)));
        }
	  }
      object=(PObject)((DWORD)object+object->size);
    }
    leaf=(PLeaf)((DWORD)leaf+leaf->size);
  }
  printf("\n");
}

void SaveToFile(void)
{
  DWORD  dwSize;
  HANDLE fhandle;

  if ((fhandle=CreateFile("c:\\test.dat",GENERIC_READ|GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0))==INVALID_HANDLE_VALUE) return;

  WriteFile(fhandle,root,root->size,&dwSize,0);
  CloseHandle(fhandle);
}

////////////////////////////////////////////////////////////////////////////////////
// 节目数据生成例程
void make_demo(BYTE* stream)
{
  DWORD i;
  RECT R;
  PRoot root;

  root=(PRoot)stream;
  DoMakeRoot(root);

  /*
  DoAddLeaf(root, 3600000);
  SetRect(&R, 0, 0, 16, 16);
  DoAddWindow(root, &R, 1, 16, 16, dibbuffer2);
  SetRect(&R, 16, 4, 32, 12);
  DoAddWindow(root, &R, 1, 16, 8, dibbuffer1);
  SetRect(&R, 32, 0, 64, 16);
  DoAddString(root, &R, "01234567890abcedfghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890abcedfghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 0, 3, 0x0000FF);
  */

  DoAddLeaf(root, 30000);
  SetRect(&R, 0, 0, 64, 16);
  //DoAddString(root, &R, "0123456789", 0, 3, 0x0000FF);
  //DoAddFontSetText(root, &R, "0123456789", "D:\\FontSet\\WINFONT_楷体_GB2312_24.dat", 3, 0xFF);
  DoAddText(root, &R, 2, "宋体", 14, 65280, "1234你好");
  //SetRect(&R, 0, 0, 16, 16);
  //DoAddWindow(root, &R, 1, 16, 16, dibbuffer2);

  //DoAddLeaf(root, 3000);
  //SetRect(&R, 0, 0, 64, 16);
  //DoAddString(root, &R, "abcdefg", 0, 3, 0x0000FF);

/////////////////////////////////////////////////////////////////////////////////////////////
  //打印节目数据和结构
  //SaveToFile();
  printf("-------------   显示数据   -------------\n");
  for (i=1; i<=root->size; i++)
  {
    printf("0x%0.2X,", stream[i-1]);
    
    if ((i % 8)==0) printf("\n");
  }
  printf("\n----------------------------------------\n");
  PrintTree(root);
/////////////////////////////////////////////////////////////////////////////////////////////
}

void fontset_demo(char* filename, BYTE* stream)
{
  FILE* fp;
  PRoot root;
  DWORD size;
  fp=fopen(filename, "r");
  if (fp!=NULL)
  {
	root=(PRoot)stream;
	memset(root, 0, sizeof(TRoot));
	root->id=ROOT_FONTSET;
	fseek(fp, 0, SEEK_SET);
    size=fread(stream+sizeof(TRoot), 1, 1024*1024, fp);
	root->size=sizeof(TRoot)+size;
	fclose(fp);
  }
}

////////////////////////////////////////////////////////////////////////////////////
// 网络发送函数 --多个数据包
void net_send(BYTE* stream)
{
  DWORD size;
  BYTE buffer[2048];
  DWORD i, K;
  char ip[16];
  WORD port;

  net_Initialize(8881);

  //====发送起始包====
  size=DoBeginPacket(buffer, 0);
  net_Write(buffer, size, remotehost, 6666);
  Sleep(100);
  size=net_Read(buffer, 2048, ip, &port);
  if (size>0) printf("==>起始包发送成功\n\n"); else printf("==>起始包发送超时\n\n");

  //====发送数据包====
  K=GetDataPacketCount(stream);

  for (i=1; i<=K; i++)
  {
    size=DoOneDataPacket(stream, i, buffer, 0);
    net_Write(buffer, size, remotehost, 6666);
    Sleep(100);
    size=net_Read(buffer, 2048, ip, &port);
    if (size>0) printf("==>数据包%d发送成功\n\n", i); else printf("==>数据包%d发送超时\n\n", i);
  }

  //====发送结束包====
  size=DoEndPacket(buffer, K+1, 0);
  net_Write(buffer, size, remotehost, 6666);
  Sleep(100);
  size=net_Read(buffer, 2048, ip, &port);
  if (size>0) printf("==>结束包发送成功\n"); else printf("==>结束包发送超时\n");

  net_Destroy();
}

////////////////////////////////////////////////////////////////////////////////////
// 串口发送函数 --多个数据包
void com_send(BYTE* stream)
{
  DWORD size;
  BYTE buffer[2048];
  DWORD i, K;
  TDeviceInfo dev;

  uart_Initialize();

  //====发送起始包====
  size=DoBeginPacket(buffer, 0);
  uart_Write(buffer, size, NULL);;
  Sleep(500);
  size=uart_Read(buffer, 2048, &dev);
  if (size>0) printf("==>起始包发送成功\n\n"); else printf("==>起始包发送超时\n\n");

  //====发送数据包====
  K=GetDataPacketCount(stream);

  for (i=1; i<=K; i++)
  {
    size=DoOneDataPacket(stream, i, buffer, 0);
    uart_Write(buffer, size, NULL);;
    Sleep(500);
    size=uart_Read(buffer, 2048, &dev);
    if (size>0) printf("==>数据包%d发送成功\n\n", i); else printf("==>数据包%d发送超时\n\n", i);
  }

  //====发送结束包====
  size=DoEndPacket(buffer, K+1, 0);
  uart_Write(buffer, size, NULL);;
  Sleep(500);
  size=uart_Read(buffer, 2048, &dev);
  if (size>0) printf("==>结束包发送成功\n"); else printf("==>结束包发送超时\n");

  uart_Destroy();
}

////////////////////////////////////////////////////////////////////////////////////
// 网络发送例程
void net_demo()
{
  BYTE stream[65536];
  make_demo(stream);
  net_send(stream);
}

////////////////////////////////////////////////////////////////////////////////////
// 网络下载字库例程
void net_fontset()
{
  BYTE stream[1024*1024];
  fontset_demo("SoftScanFont.dat", stream);
  net_send(stream);
}

////////////////////////////////////////////////////////////////////////////////////
// 串口发送例程
void com_demo()
{
  BYTE stream[65536];
  make_demo(stream);
  com_send(stream);
}

//读取电源状态
long net_getpower()
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];
  PPKG_Respond p;
  char ip[16];
  WORD port;
  long power=-1;

  ((PPKG_Header)buffer)->Command=PKC_GET_POWER;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=0;
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  Sleep(100);
  size=net_Read(buffer, 1024, ip, &port);
  if (size>0 && buffer[0]==0x55 && buffer[size-1]==0xAA)
  {
	size=dePack(buffer, obuffer, size);
	p=((PPKG_Respond)obuffer);
	if (p->Header.Command==3 && p->Command==PKC_GET_POWER && p->Result==1)
	{
	  power=(long)p->Header.SerialNo;
	  printf("读取电源状态成功，当前电源状态:%d\r\n", p->Header.SerialNo);
	}
  }
  else
  {
	printf("读取电源状态失败\r\n");
  }
  net_Destroy();
  return power;
}

//设置电源
void net_setpower(long power)
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];

  ((PPKG_Header)buffer)->Command=PKC_SET_POWER;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=(DWORD)power;
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  net_Destroy();
}

//读取亮度
long net_getbright()
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];
  PPKG_Respond p;
  char ip[16];
  WORD port;
  long bright=-1;

  ((PPKG_Header)buffer)->Command=PKC_GET_BRIGHT;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=0;
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  Sleep(100);
  size=net_Read(buffer, 1024, ip, &port);
  if (size>0 && buffer[0]==0x55 && buffer[size-1]==0xAA)
  {
	size=dePack(buffer, obuffer, size);
	p=((PPKG_Respond)obuffer);
	if (p->Header.Command==3 && p->Command==PKC_GET_BRIGHT && p->Result==1)
	{
	  bright=(long)p->Header.SerialNo;
	  printf("读取亮度成功，当前亮度:%d\r\n", p->Header.SerialNo);
	}
  }
  else
  {
	printf("读取亮度失败\r\n");
  }
  net_Destroy();
  return bright;
}

//设置亮度
void net_setbright(long bright)
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];

  ((PPKG_Header)buffer)->Command=PKC_SET_BRIGHT;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=(DWORD)bright;
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  net_Destroy();
}

//读取亮度
long net_getleaf()
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];
  PPKG_Respond p;
  char ip[16];
  WORD port;
  long index=-1;

  ((PPKG_Header)buffer)->Command=PKC_GET_LEAF;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=0;
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  Sleep(100);
  size=net_Read(buffer, 1024, ip, &port);
  if (size>0 && buffer[0]==0x55 && buffer[size-1]==0xAA)
  {
	size=dePack(buffer, obuffer, size);
	p=((PPKG_Respond)obuffer);
	if (p->Header.Command==3 && p->Command==PKC_GET_LEAF && p->Result==1)
	{
	  index=(long)p->Header.SerialNo;
	  printf("读取当前播放页面序号成功，当前播放页面序号:%d\r\n", p->Header.SerialNo);
	}
  }
  else
  {
	printf("读取当前播放页面序号失败\r\n");
  }
  net_Destroy();
  return index;
}

//设置亮度
void net_setleaf(long index)
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];

  ((PPKG_Header)buffer)->Command=PKC_SET_LEAF;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=(DWORD)index;
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  net_Destroy();
}

//校正控制卡时间
void net_adjusttime()
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];
  SYSTEMTIME time;

  ((PPKG_Header)buffer)->Command=PKC_ADJUST_TIME;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=0;
  GetLocalTime(&time);
  memcpy((SYSTEMTIME*)(buffer+sizeof(TPKG_Header)), &time, sizeof(SYSTEMTIME));
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header)+sizeof(SYSTEMTIME));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  net_Destroy();
}

//光带屏--读取光带颜色
void net_getfillcolor(BYTE* pdata)
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];
  PPKG_Respond p;
  char ip[16];
  WORD port;

  ((PPKG_Header)buffer)->Command=PKC_GET_FILLCOLOR;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=0;
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header));
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  Sleep(100);
  size=net_Read(buffer, 1024, ip, &port);
  if (size>0 && buffer[0]==0x55 && buffer[size-1]==0xAA)
  {
	size=dePack(buffer, obuffer, size);
	p=((PPKG_Respond)obuffer);
	if (p->Header.Command==3 && p->Command==PKC_GET_FILLCOLOR && p->Result==1)
	{
	  memcpy(pdata, (BYTE*)(obuffer+sizeof(TPKG_Respond)), FILLCOLOR_BUFFER_LENGTH);
      printf("读取光带颜色成功\r\n");
	}
  }
  else
  {
	printf("读取光带颜色失败\r\n");
  }
  net_Destroy();
}

//光带屏--设置光带颜色
void net_setfillcolor(BYTE* pdata)
{
  DWORD size;
  BYTE buffer[1024];
  BYTE obuffer[1024];

  ((PPKG_Header)buffer)->Command=PKC_SET_FILLCOLOR;
  ((PPKG_Header)buffer)->srcAddr=0;
  ((PPKG_Header)buffer)->dstAddr=0;  //填写控制卡地址
  ((PPKG_Header)buffer)->SerialNo=0;
  memcpy((BYTE*)(buffer+sizeof(TPKG_Header)), pdata, FILLCOLOR_BUFFER_LENGTH);
  size=Pack((BYTE*)buffer, (BYTE*)obuffer, sizeof(TPKG_Header)+FILLCOLOR_BUFFER_LENGTH);
  net_Initialize(8881);
  net_Write(obuffer, size, remotehost, 6666);
  net_Destroy();
}

void main(void)
{
  net_demo();
  //net_getpower();
  //net_getbright();
  //com_demo();
  //com_adjusttime();
  getch();
}